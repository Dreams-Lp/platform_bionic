Bionic comes with a processed set of all of the uapi Linux kernel headers that
can safely be included by userland applications and libraries.

These clean headers are automatically generated by several scripts located
in the 'bionic/kernel/tools' directory. The tools process the original
unmodified kernel headers in order to get rid of many annoying
declarations and constructs that usually result in compilation failure.

The 'clean headers' only contain type and macro definitions, with the
exception of a couple static inline functions used for performance
reason (e.g. optimized CPU-specific byte-swapping routines).

They can be included from C++, or when compiling code in strict ANSI mode.
They can be also included before or after any Bionic C library header.

Here are the directories involved in the 

  * 'external/kernel-headers/original/'
    Contains the uapi kernel headers found in the android kernel. Note this
    includes header files that are generated to build the kernel.

  * 'bionic/libc/kernel/uapi'
    Contains the cleaned kernel headers and mirrors the directory structure
    in 'external/kernel-headers/original/uapi/'.

  * 'bionic/libc/kernel/tools'
    Contains various Python and shell scripts used to get and re-generate
    the headers.

The tools to get/parse the headers:

  * tools/generate_uapi_headers.sh
    Checks out the android kernel and generates all uapi header files.
    copies all the changed files into external/kernel-headers.

  * tools/clean_header.py
    Prints the clean version of a given kernel header. With the -u option,
    this will also update the corresponding clean header file if its
    content has changed. You can also process more than one file with -u.

  * tools/update_all.py
    Automatically update all clean headers from the content of 
    'external/kernel-headers/original'.


HOW TO UPDATE THE HEADERS WHEN NEEDED:
======================================

IMPORTANT IMPORTANT:

  WHEN UPDATING THE HEADERS, ALWAYS CHECK THAT THE NEW CLEAN HEADERS DO
  NOT BREAK THE KERNEL <-> USER ABI, FOR EXAMPLE BY CHANGING THE SIZE
  OF A GIVEN TYPE. THIS TASK CANNOT BE EASILY AUTOMATED AT THE MOMENT

Grab the latest headers from the android kernel by running this command:

  bionic/kernel/tools/generate_uapi_headers.sh --download-kernel

Next, run this command to copy the parsed files to bionic/libc/kernel/uapi:

  bionic/kernel/tools/update_all.py

After this, you will need to build/test the tree to make sure that these
changes do not introduce any errors.


HOW THE CLEANUP PROCESS WORKS:
==============================

This section describes the actions performed by the cleanup program when
it processes the original kernel headers into clean ones:

1. Optimize well-known macros (e.g. __KERNEL__, __KERNEL_STRICT_NAMES)

    This pass gets rid of everything that is guarded by a well-known macro
    definition. This means that a block like:

       #ifdef __KERNEL__
       ....
       #endif

    Will be totally omitted from the output. The optimizer is smart enough to
    handle all complex C-preprocessor conditional expression appropriately.
    This means that, for example:

       #if defined(__KERNEL__) || defined(FOO)
       ...
       #endif

    Will be transformed into:

       #ifdef FOO
       ...
       #endif

    See tools/defaults.py for the list of well-known macros used in this pass,
    in case you need to update it in the future.

    Note that this also removes any reference to a kernel-specific
    configuration macro like CONFIG_FOO from the clean headers.


2. Remove variable and function declarations:

  This pass scans non-directive text and only keeps things that look like a
  typedef/struct/union/enum declaration. This allows us to get rid of any
  variables or function declarations that should only be used within the kernel
  anyway (and which normally *should* be guarded by an #ifdef __KERNEL__ ...
  #endif block, if the kernel writers were not so messy).

  There are, however, a few exceptions: it is seldom useful to keep the
  definition of some static inline functions performing very simple operations.
  A good example is the optimized 32-bit byte-swap function found in:

    arch-arm/asm/byteorder.h

  The list of exceptions is in tools/defaults.py in case you need to update it
  in the future.

  Note that we do *not* remove macro definitions, including these macro that
  perform a call to one of these kernel-header functions, or even define other
  functions. We consider it safe since userland applications have no business
  using them anyway.


3. Whitespace cleanup:

  The final pass removes any comments and empty lines from the final headers.


4. Add a standard disclaimer:

  A message like:

    "do not edit directly - file was auto-generated by ...."

  Is prepended to each generated header.
