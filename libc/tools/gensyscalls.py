#!/usr/bin/python
#
# this tool is used to generate the syscall assmbler templates
# to be placed into arch-x86/syscalls, as well as the content
# of arch-x86/linux/_syscalls.h
#

import sys, os.path, glob, re, commands, filecmp, shutil

from bionic_utils import *

# get the root Bionic directory, simply this script's dirname
#
bionic_root = find_bionic_root()
if not bionic_root:
    print "could not find the Bionic root directory. aborting"
    sys.exit(1)

if bionic_root[-1] != '/':
    bionic_root += "/"

print "bionic_root is %s" % bionic_root

# temp directory where we store all intermediate files
bionic_temp = "/tmp/bionic_gensyscalls/"

# all architectures, update as you see fit
all_archs = [ "arm", "x86" ]

def make_dir( path ):
    if not os.path.exists(path):
        parent = os.path.dirname(path)
        if parent:
            make_dir(parent)
        os.mkdir(path)

def create_file( relpath ):
    dir = os.path.dirname( bionic_temp + relpath )
    make_dir(dir)
    return open( bionic_temp + relpath, "w" )


# All generated assembly stubs begin with the following header
#
generic_stub_header = """/* auto-generated by gensyscalls.py - DO NOT EDIT */
#include <machine/asm.h>

"""

# Used to start a public stub entry point
# This one will be exported by the C library
generic_stub_func_start_public = """\
ENTRY(%(func)s)
"""

# Used to start a hidden stub entry point
# Only the C library code can use it, it won't be visible outside of it.
generic_stub_func_start_hidden = """\
ENTRY_PRIVATE(%(func)s)
"""

# Used to terminate a stub function definition
generic_stub_func_end = """\
END(%(func)s)
"""

# Normal ARM stub implementation, when less than 4 registers are needed
arm_stub_call_default = """\
#define __NR_%(name)s  %(arm_id)d

    .save   {r4, r7}
    stmfd   sp!, {r4, r7}
    ldr     r7, =__NR_%(name)s
    swi     #0
    ldmfd   sp!, {r4, r7}
    movs    r0, r0
    bxpl    lr
    b       __set_syscall_errno
"""

# Extended ARM stub implementation, when more than 4 registers are needed
# This works for up to 7 parameters.
arm_stub_call_long = """\
#define __NR_%(name)s  %(arm_id)d

    mov     ip, sp
    .save   {r4, r5, r6, r7}
    stmfd   sp!, {r4, r5, r6, r7}
    ldmfd   ip, {r4, r5, r6}
    ldr     r7, =__NR_%(name)s
    swi     #0
    ldmfd   sp!, {r4, r5, r6, r7}
    movs    r0, r0
    bxpl    lr
    b       __set_syscall_errno
"""


# x86 assembler templates for each syscall stub
#
x86_registers = [ "%ebx", "%ecx", "%edx", "%esi", "%edi", "%ebp" ]

# TODO: Implement this with syscall instruction instead.
x86_stub_call_default = """\
#define __NR_%(name)s  %(x86_id)d

    movl    $__NR_%(name)s, %%eax
    int     $0x80
    cmpl    $-129, %%eax
    jb      1f
    negl    %%eax
    pushl   %%eax
    call    __set_errno
    addl    $4, %%esp
    orl     $-1, %%eax
1:
"""

def param_uses_64bits(param):
    """Returns True iff a syscall parameter description corresponds
       to a 64-bit type."""
    param = param.strip()
    # First, check that the param type begins with one of the known
    # 64-bit types.
    if not ( \
       param.startswith("int64_t") or param.startswith("uint64_t") or \
       param.startswith("loff_t") or param.startswith("off64_t") or \
       param.startswith("long long") or param.startswith("unsigned long long") or
       param.startswith("signed long long") ):
           return False

    # Second, check that there is no pointer type here
    if param.find("*") >= 0:
            return False

    # Ok
    return True

def count_arm_param_registers(params):
    """This function is used to count the number of register used
       to pass parameters when invoking a thumb or ARM system call.
       This is because the ARM EABI mandates that 64-bit quantities
       must be passed in an even+odd register pair. So, for example,
       something like:

             foo(int fd, off64_t pos)

       would actually need 4 registers:
             r0 -> int
             r1 -> unused
             r2-r3 -> pos
   """
    count = 0
    for param in params:
        if param_uses_64bits(param):
            if (count & 1) != 0:
                count += 1
            count += 2
        else:
            count += 1
    return count


def count_generic_param_registers(params):
    count = 0
    for param in params:
        if param_uses_64bits(param):
            count += 2
        else:
            count += 1
    return count




class State:
    def __init__(self):
        self.old_stubs = []
        self.new_stubs = []
        self.other_files = []
        self.syscalls = []

    def gen_arm_stub(self, t):
        if t["arm_id"] < 0:
            return

        num_regs = count_arm_param_registers(t["params"])
        result   = generic_stub_header % t

        if t["hidden"]:
            result += generic_stub_func_start_hidden % t
        else:
            result += generic_stub_func_start_public % t

        if num_regs > 4:
            result = result + arm_stub_call_long % t
        else:
            result = result + arm_stub_call_default % t

        result += generic_stub_func_end % t
        t["asm-arm"] = result

    def gen_x86_stub(self, t):
        if t["x86_id"] < 0:
            return

        result = generic_stub_header % t
        if t["hidden"]:
            result += generic_stub_func_start_hidden % t
        else:
            result += generic_stub_func_start_public % t

        num_regs   = count_generic_param_registers(t["params"])
        stack_bias = 4
        call_id    = t["call_id"]

        if call_id >= 0:
            # We'll ignore numparams here because in reality, if there is a
            # dispatch call (like a socketcall syscall) there are actually
            # only 2 arguments to the syscall and 2 regs we have to save:
            #   %ebx <--- Argument 1 - The call id of the needed vectored
            #                          syscall (socket, bind, recv, etc)
            #   %ecx <--- Argument 2 - Pointer to the rest of the arguments
            #                          from the original function called (socket())

            # save the regs we need
            result += "    pushl   %ebx\n"
            result += "    pushl   %ecx\n"
            stack_bias += 8

            # set the call id (%ebx)
            result += "    mov     $%d, %%ebx\n" % (call_id)

            # set the pointer to the rest of the args into %ecx
            result += "    mov     %esp, %ecx\n"
            result += "    addl    $%d, %%ecx\n" % (stack_bias)
        else:
            for r in range(num_regs):
                result += "    pushl   %s\n" % x86_registers[r]
                stack_bias += 4

            for r in range(num_regs):
                result += "    mov     %d(%%esp), %s\n" % (stack_bias+r*4, x86_registers[r])

        result += x86_stub_call_default % t

        if call_id >= 0:
            # now restore the saved regs
            result += "    popl    %ecx\n"
            result += "    popl    %ebx\n"
        else:
            for r in range(num_regs):
                result += "    popl    %s\n" % x86_registers[num_regs-r-1]

        result += "    ret\n"
        result += generic_stub_func_end % t
        t["asm-x86"] = result

    def process_file(self,input):
        parser = SysCallsTxtParser()
        parser.parse_file(input)
        self.syscalls = parser.syscalls
        parser = None

        for t in self.syscalls:
            self.gen_arm_stub(t)
            self.gen_x86_stub(t)
            if t["call_id"] >= 0 and t["x86_id"] < 0:
                E("call_id for dispatch syscalls is only supported for x86 in '%s'" % t["name"])

    def gen_NR_syscall(self,fp,name,id):
        fp.write( "#define __NR_%-25s    (__NR_SYSCALL_BASE + %d)\n" % (name,id) )

    # now dump the content of linux/_syscalls.h
    def gen_linux_syscalls_h(self):
        path = "include/sys/linux-syscalls.h"
        D( "generating "+path )
        fp = create_file( path )
        fp.write( "/* auto-generated by gensyscalls.py, do not touch */\n" )
        fp.write( "#ifndef _BIONIC_LINUX_SYSCALLS_H_\n\n" )
        fp.write( "#if !defined __ASM_ARM_UNISTD_H && !defined __ASM_I386_UNISTD_H\n" )
        fp.write( "#if defined __arm__ && !defined __ARM_EABI__ && !defined __thumb__\n" )
        fp.write( "  #  define __NR_SYSCALL_BASE  0x900000\n" )
        fp.write( "  #else\n" )
        fp.write( "  #  define  __NR_SYSCALL_BASE  0\n" )
        fp.write( "  #endif\n\n" )

        # first, all common syscalls
        for sc in self.syscalls:
            sc_id  = sc["arm_id"]
            sc_id2 = sc["x86_id"]
            sc_name = sc["name"]
            if sc_id == sc_id2 and sc_id >= 0:
                self.gen_NR_syscall( fp, sc_name, sc_id )

        # now, all arm-specific syscalls
        fp.write( "\n#ifdef __arm__\n" );
        for sc in self.syscalls:
            sc_id  = sc["arm_id"]
            sc_id2 = sc["x86_id"]
            sc_name = sc["name"]
            if sc_id != sc_id2 and sc_id >= 0:
                self.gen_NR_syscall( fp, sc_name, sc_id )
        fp.write( "#endif\n" );

        gen_syscalls = {}
        # finally, all i386-specific syscalls
        fp.write( "\n#ifdef __i386__\n" );
        for sc in self.syscalls:
            sc_id  = sc["arm_id"]
            sc_id2 = sc["x86_id"]
            sc_name = sc["name"]
            if sc_id != sc_id2 and sc_id2 >= 0 and sc_name not in gen_syscalls:
                self.gen_NR_syscall( fp, sc_name, sc_id2 )
                gen_syscalls[sc_name] = True
        fp.write( "#endif\n" );

        fp.write( "\n#endif\n" )
        fp.write( "\n#endif /* _BIONIC_LINUX_SYSCALLS_H_ */\n" );
        fp.close()
        self.other_files.append( path )


    # now dump the content of linux/_syscalls.h
    def gen_linux_unistd_h(self):
        path = "include/sys/linux-unistd.h"
        D( "generating "+path )
        fp = create_file( path )
        fp.write( "/* auto-generated by gensyscalls.py, do not touch */\n" )
        fp.write( "#ifndef _BIONIC_LINUX_UNISTD_H_\n\n" );
        fp.write( "#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n" )

        for sc in self.syscalls:
            fp.write( sc["decl"]+"\n" )

        fp.write( "#ifdef __cplusplus\n}\n#endif\n" )
        fp.write( "\n#endif /* _BIONIC_LINUX_UNISTD_H_ */\n" );
        fp.close()
        self.other_files.append( path )

    # now dump the contents of syscalls.mk
    def gen_arch_syscalls_mk(self, arch):
        path = "arch-%s/syscalls.mk" % arch
        D( "generating "+path )
        fp = create_file( path )
        fp.write( "# auto-generated by gensyscalls.py, do not touch\n" )
        fp.write( "syscall_src := \n" )
        arch_test = {
            "arm": lambda x: x.has_key("asm-arm") or x.has_key("asm-thumb"),
            "x86": lambda x: x.has_key("asm-x86"),
        }

        for sc in self.syscalls:
            if arch_test[arch](sc):
                fp.write("syscall_src += arch-%s/syscalls/%s.S\n" %
                         (arch, sc["func"]))
        fp.close()
        self.other_files.append( path )

    # now generate each syscall stub
    def gen_syscall_stubs(self):
        for sc in self.syscalls:
            if sc.has_key("asm-arm") and 'arm' in all_archs:
                fname = "arch-arm/syscalls/%s.S" % sc["func"]
                D2( ">>> generating "+fname )
                fp = create_file( fname )
                fp.write(sc["asm-arm"])
                fp.close()
                self.new_stubs.append( fname )

            if sc.has_key("asm-thumb") and 'arm' in all_archs:
                fname = "arch-arm/syscalls/%s.S" % sc["func"]
                D2( ">>> generating "+fname )
                fp = create_file( fname )
                fp.write(sc["asm-thumb"])
                fp.close()
                self.new_stubs.append( fname )

            if sc.has_key("asm-x86") and 'x86' in all_archs:
                fname = "arch-x86/syscalls/%s.S" % sc["func"]
                D2( ">>> generating "+fname )
                fp = create_file( fname )
                fp.write(sc["asm-x86"])
                fp.close()
                self.new_stubs.append( fname )


    def  regenerate(self):
        D( "scanning for existing architecture-specific stub files" )

        bionic_root_len = len(bionic_root)

        for arch in all_archs:
            arch_path = bionic_root + "arch-" + arch
            D( "scanning " + arch_path )
            files = glob.glob( arch_path + "/syscalls/*.S" )
            for f in files:
                self.old_stubs.append( f[bionic_root_len:] )

        D( "found %d stub files" % len(self.old_stubs) )

        if not os.path.exists( bionic_temp ):
            D( "creating %s" % bionic_temp )
            os.mkdir( bionic_temp )

#        D( "p4 editing source files" )
#        for arch in all_archs:
#            commands.getoutput( "p4 edit " + arch + "/syscalls/*.S " )
#            commands.getoutput( "p4 edit " + arch + "/syscalls.mk" )
#        commands.getoutput( "p4 edit " + bionic_root + "include/sys/linux-syscalls.h" )

        D( "re-generating stubs and support files" )

        self.gen_linux_syscalls_h()
        for arch in all_archs:
            self.gen_arch_syscalls_mk(arch)
        self.gen_linux_unistd_h()
        self.gen_syscall_stubs()

        D( "comparing files" )
        adds    = []
        edits   = []

        for stub in self.new_stubs + self.other_files:
            if not os.path.exists( bionic_root + stub ):
                # new file, git add it
                D( "new file:     " + stub)
                adds.append( bionic_root + stub )
                shutil.copyfile( bionic_temp + stub, bionic_root + stub )

            elif not filecmp.cmp( bionic_temp + stub, bionic_root + stub ):
                D( "changed file: " + stub)
                edits.append( stub )

        deletes = []
        for stub in self.old_stubs:
            if not stub in self.new_stubs:
                D( "deleted file: " + stub)
                deletes.append( bionic_root + stub )


        if adds:
            commands.getoutput("git add " + " ".join(adds))
        if deletes:
            commands.getoutput("git rm " + " ".join(deletes))
        if edits:
            for file in edits:
                shutil.copyfile( bionic_temp + file, bionic_root + file )
            commands.getoutput("git add " +
                               " ".join((bionic_root + file) for file in edits))

        commands.getoutput("git add %s%s" % (bionic_root,"SYSCALLS.TXT"))

        if (not adds) and (not deletes) and (not edits):
            D("no changes detected!")
        else:
            D("ready to go!!")

D_setlevel(1)

state = State()
state.process_file(bionic_root+"SYSCALLS.TXT")
state.regenerate()
